---
title: "💡 비트마스크(BitMask)"
description: "개발 상식"
date: 2022-05-15
update: 2022-05-15
tags:
  - 개발상식
  - Java
  - 비트마스크
series: "💡 Algorithm"
---

## 🧷 비트마스크
현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현하고, 이는 이진법 관련 연산을 아주 빨리 처리할 수 있다는 장점이 있다. 이와 같은 특성을 이용해 정수의 이진수 표현을 자료 구조로 쓰는 기법을 말한다.

> 집합의 요소들의 구성 여부를 표현할 때 유용한 알고리즘이다.

### 🪚 장점
**더 빠른 수행 시간**
- 비트 마스크 연산은 $O(1)$ 에 구현되는 것이 많아 다른 자료 구조보다 훨씬 빨리 동작한다.
- 물론 비트마스크를 사용할 수 있다는 말은 원소의 수가 많지 않다는 의미이므로, 엄청나게 큰 속도 향상은 아니다.

**간결한 코드**
- 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있어 짧은 코드를 작성할 수 있다.

**더 작은 메모리 사용량**
- 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있다.
- 이로 인해 더 많은 데이터를 미리 계산해서 저장해 둘 수 있게 된다.

**연관 배열을 배열로 대체**
- 집합을 배열의 인덱스로 표현할 수 있다.

**DP나 순열 등 배열 활용만으로 해결할 수 없는 문제 해결**

### 🪚 비트마스킹 활용
> 0과 1로 flag 활용하기

`[1,2,3,4,5]` 라는 집합이 있다고 가정한다. 여기서 임의로 몇 개를 골라 뽑아 확인해야 하는 상황이 주어졌다. (부분 집합을 의미)

```java
{1}, {2}, ... , {1,2}, {1,2,5}, {1,2,3,4,5}
```

비트마스킹을 통해, 각 요소를 인덱스처럼 표현하여 효율적인 접근을 할 수 있다.

```java
[1,2,3,4,5] -> 11111
[2,3,4,5]   -> 11110
[1,2,5]     -> 10011
[3]         -> 00100
```
이러한 2진수를 10진수로 변환하여 부분집합을 정수를 통해 나타내는 것도 가능하다.

> `11111` -> 10진수 변환 -> `31`

이로써, 해당 부분집합에 `i` 를 추가하고 싶다면 `i` 번째 비트를 1로 바꿔주어 표현할 수 있다. 그리고 이때 **비트 연산**을 사용한다.

### 🪚 비트 연산
- `AND(&)` : 대응하는 두 비트가 모두 1일때만 1을 반환
- `OR(|)` : 대응하는 두 비트 중 하나라도 1일때 1을 반환
- `XOR(^)` : 대응하는 두 비트가 서로 다를 때만 1을 반환
- `NOT(~)` : 비트 값을 반전하여 반환
- `SHIFT(>>, <<)` : 왼쪽 혹은 오른쪽으로 비트를 옮겨 반환
  - 왼쪽 SHIFT (`A << B`) : `A * 2^B`
  - 오른쪽 SHIFT (`A >> B`) : `A / 2^B`

```java
[왼쪽]   0001 → 0010 → 0100 → 1000 : 1 → 2 → 4 → 8
[오른쪽] 1000 → 0100 → 0010 → 0001 : 8 → 4 → 2 → 1
```

### 🪚 예제를 통한 구현
피자집이 있다. 여기에는 0부터 19까지의 번호를 갖는 스무 가지의 토핑이 있고, 주문 시 토핑을 넣거나 뺄 수 있다.
- 그렇다면 한 피자의 정보는 스무 종류의 원소만을 가지는 집합으로 표현할 수 있다.
- 이를 `boolean[]` 으로 표현할 수도 있지만, 비트마스킹을 사용한다.

**공집합과 꽉 찬 집합**
- 토핑을 올리지 않은 피자와 모든 토핑을 올린 피자를 표현하려면 아래와 같이 할 수 있다.

```java
// 토핑이 없는 피자
int emptyPizza = 0;
// 스무 개의 토핑을 모두 올린 피자
int fullPizza = (1 << 20) - 1;
```
- `1 << 20` 은 1뒤에 20개의 0이 있는 정수이므로, 여기서 1을 빼면 20개의 비트가 모두 켜진 정수를 얻을 수 있다.

**원소 추가**
- 집합의 가장 기본적인 연산은 원소를 추가하고 삭제하는 것이다.
- 비트마스크를 사용한 집합에서 원소를 추가한다는 것은 해당 비트를 킨다는 의미이다.

```java
// 토핑 목록에 p번 토핑을 추가하고 싶은 경우
toppings |= (1 << p);
```
- `1 << p` 는 p번째 비트만 켜진 정수이다.
- 이미 `toppings` 에 p번 토핑이 추가된 경우 값은 변하지 않는다.

**원소 삭제**
```java
// 토핑 목록에서 p번 토핑을 삭제하고 싶은 경우 (토핑 목록에 p번 토핑이 있어야 함)
toppings -= (1 << p);

// 토핑이 없을 때도 정상적으로 동작하는 삭제
toppings &= ~(1 << p);
```

**원소 포함 여부 확인**
- 토핑 목록에 원하는 토핑이 잘 추가되었는지 확인한다.

```java
if ((toppings & (1 << p)) == (1 << p))
  System.out.println("Topping is in!");
```
- `&` 연산의 결과값은 0 또는 `1 << p` 이다.

**원소의 토글**
- 해당 비트가 켜져 있으면 끄고, 꺼져 있다면 킨다.
- `XOR` 연산을 사용한다.

```java
toppings ^= (1 << p);
```

**집합의 크기 구하기**
- 가장 간단한 방법은 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세는 방법이다.
- 하지만 JAVA에서는 이와 관련된 내장 명령어를 제공한다.

```java
System.out.println(Integer.bitCount(toppings));
```

---

## 📕 참고
- [Tech Interview for developer](https://gyoogle.dev/blog)
- [**프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략**] 구종만