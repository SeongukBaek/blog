---
title: "💡 알고리즘 분석"
description: "종만북"
date: 2022-03-28
update: 2022-03-28
tags:
  - 종만북
series: "💡 Algorithm"
---

<em>[프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 - 구종만]을 읽고 정리한 POST입니다.</em>

## 💡 개관
어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법을 **알고리즘**이라고 한다. 또 다르게는, 같은 일을 하는 여러 가지의 방법이 존재한다. 이때 주어진 문제를 해결하는 한 가지 방법을 명료하게 써놓은 것을 **알고리즘**이라고 한다.

이러한 측면에서, 주관적이거나 모호한 것은 알고리즘이라고 할 수 없다. "서울 신촌역에서 춘천에 간다." 라는 예시를 들었을 때, 다음은 정당한 알고리즘이라고 할 수 있다.

1. 지하철 2호선을 타고 시청역으로 간다.
2. 지하철 1호선으로 갈아타고 청량리역으로 간다.
3. 경춘선을 타고, 춘천역에서 내린다.

하지만 다음의 경우는 매우 주관적이며, 따라서 본질적으로 모호하기에 알고리즘이라고 할 수 없다.

1. 강동구 쪽으로 가는 버스를 탄다.
2. 동서울 버스 터미널 근처에 온 것 같으면 내린다.
3. 춘천 쪽으로 가는 버스를 타고, 한참 가다 내린다.

한 문제를 해결하는 데 여러 개의 알고리즘이 있을 수 있다. 그렇다면 어떠한 알고리즘을 만들어야 할까? 알고리즘에 대한 평가 기준은 **"시간"과 "공간"**이 있다.

- **시간**
  - 알고리즘이 적은 시간을 사용한다 = 더 빠르게 동작한다
  - 알고리즘의 수행 속도와 특성을 분석하는 능력을 배양할 필요가 있다.
- **공간**
  - 알고리즘이 적은 공간을 사용한다 = 더 적은 용량의 메모리를 사용한다
  - 이론적으로 아무리 빠르더라도 너무 많은 메모리 공간을 요구한다면 수행할 수 없을 것이다.

두 평가 기준은 서로 상충되어 tradeoff를 발생시키는 경우가 많다. 이후에 나올 알고리즘들에서 다루도록 한다.

---

## 💡 알고리즘의 시간 복잡도 분석
### 🔍 도입
좀 더 빠른 알고리즘을 만들기 위해서는 알고리즘의 속도를 어떻게 측정할지에 대한 기준을 정해야 한다. 가장 직관적인 방법은 "각각을 프로그램으로 구현한 뒤 같은 입력에 대해 두 프로그램의 수행 시간을 측정하는 것"이다. 실구현 시 사용자가 느끼기에 너무 느리다면 소용이 없기 때문에 현실적으로도 유용한 방법 중 하나이다.

하지만 "프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 **부적합**"하다.
- 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어는 물론이고 운영체제, 컴파일러까지 **수많은 요소에 의해 바뀔 수 있기 때문**이다.
- 프로그램의 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못하는 문제도 있다.
  - 알고리즘은 언제나 같은 속도로 동작하는 것이 아니며, 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있다.

**반복문이 지배한다**<br/>
자동차 2대가 있고, 서울에서 부산까지 가려고 할 때 어느 자동차를 타야 빨리 도착할 수 있을지 알고 싶다. 아래는 자동차에 대한 정보이다.

|항목|자동차A|자동차B|
|---|---|---|
|시동 거는데 걸리는 시간|3분|5초|
|문 열었다 닫는 데 걸리는 시간|1분|0초|
|운전석 등받이 조절에 걸리는 시간|5분|0초|
|앞 유리 닦는데 걸리는 시간|4분|0초|
|최대 시속|200km/h|40km/h|

사실 자동차 B는 자전거이다. 시동 거는데 걸리는 시간을 제외하고는 다른 부가적인 시간들이 필요없지만, 그렇다고 해서 자전거를 타고 서울에서 부산까지 가려는 사람은 별로 없을 것이다. 
- 오래 걸리는 항목들은 사실 출발할 때 한 번만 적용되는 반면, 최대 시속은 달리는 내내 적용되기 때문이다.

이렇게 한 가지 항목이 전체의 대소를 좌지우지하는 것을 "지배한다(dominate)"라고 표현한다.

그럼 알고리즘에서 수행 시간을 지배하는 것은 무엇일까? 바로 **반복문**이다.
- 입력에 상관없이 항상 같은 수행 시간을 갖는 알고리즘도 있지만, 대개 입력 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다.
  - 입력이 작을 수록 반복 외의 다른 요소들의 비중이 클 수 있지만, **입력이 커질 수록 반복문이 알고리즘의 수행 시간을 지배**하게 된다.

> 따라서, 대개 알고리즘의 수행 시간을 **반복문이 수행되는 횟수**로 측정한다. (입력의 크기에 대한 함수로 표현)

아래는 주어진 배열에서 가장 많이 등장하는 수를 찾는 코드이다. 수행 시간은 배열의 크기 `N` 에 따라서 변한다. `N` 번 수행되는 반복문이 두 개 겹쳐있어 반복문의 가장 안쪽은 항상 `N^2` 번 실행되고, 따라서 이 알고리즘의 수행 시간은 `N^2` 이다.

```java
private static int majority(int[] array) {
    int N = array.length;
    int majority = -1, majorityCnt = 0;
    
    for (int i = 0; i < N; i++) {
      // array에 등장하는 요소의 수를 센다.
      int V = array[i], cnt = 0;
      for (int j = 0; j < N; j++) {
        if (V == array[j])
          cnt++;
      }
      
      // 지금까지의 최대 빈도와 비교 후 최신화
      if (cnt > majorityCnt) {
        majorityCnt = cnt;
        majority = V;
      }
    }
    
    return majority;
}
```

만약 입력으로 주어지는 숫자들의 범위가 작다면, 배열을 이용해 각 숫자가 등장하는 횟수를 쉽게 셀 수 있고, 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 된다. 아래 코드가 이를 구현했다. 

```java
private static int majority2(int[] array) {
  int N = array.length;
  int[] frequency = new int[101];
  for (int j : array) {
    frequency[j]++;
  }
  
  int majority = 0;
  for (int i = 1; i <= 100; i++) {
    if (frequency[i] > frequency[majority])
        majority = i;
  }
  
  return majority;
}
```

- 반복문이 2개가 있다. 하나는 `N` 번 수행되고, 하나는 100번 수행된다. 고로 전체 수행 횟수는 `N + 100` 이 된다. 
- 그런데 `N` 이 커지면 커질 수록 사실 100번 수행하는 반복문은 수행 시간에서 차지하는 비중이 줄어들게 된다. 따라서 궁극적으로는 이 알고리즘의 수행 시간을 `N` 이라고 쓴다.

### 🔍 선형 시간 알고리즘
**다이어트 현황 파악: 이동 평균 계산하기**<br/>
이동 평균(moving average)은 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준이다. N개의 측정치가 주어질 때 매달 M달 간의 이동 평균을 계산하는 프로그램은 어떻게 짜야 할까?
- 각 위치에서 지난 M개 측정치의 합을 구하고, 이를 M으로 나눈다.

```java
 private static double[] movingAverage(double[] A, int M) {
    int N = A.length;
    double[] ret = new double[N];
    int retIdx = 0;
    for (int i = M-1; i < N; i++) {
      double partialSum = 0;
      for (int j = 0; j < M; j++)
        partialSum += A[i-j];
      ret[retIdx++] = partialSum/M;
    }
    return ret;
}
```

- 이는 간단하게 두 개의 for문을 사용하는 코드로 구현할 수 있다.
  - 즉 두 개의 for문에 의해 지배된다. 
- 이 코드의 수행 시간을 좀 더 줄이는 방법은 없을까?

> 중요한 아이디어는 중복된 계산을 없애는 것이다.

측정치가 M개는 되어야 이동 평균을 계산할 수 있으니, 태어난 이후 M-1일부터 이동 평균을 계산할 수 있다. 
- 아래 표에서 M-1일의 이동 평균과 M일의 이동 평균에 포함되는 숫자들을 찾아본다.

|날짜|0|1|2|3|4|...|M-1|M|M+1|
|---|---|---|---|---|---|---|---|---|---|
|몸무게|3.5|3.5|3.5|3.6|3.5|...|80.2|80.1|80.3|

- 0일과 M일의 몸무게를 제외하면 전부 겹친다는 것을 확인할 수 있다.
- 그렇다면 측정한 몸무게의 합을 일일이 구할 필요 없이 M-1일에 구했던 몸무게의 합에서 0일째에 측정한 몸무게를 빼고 M일째에 측정한 몸무게를 더하면 되지 않을까?

```java
 private static double[] movingAverage2(double[] A, int M) {
    int N = A.length;
    double[] ret = new double[N];
    int retIdx = 0;
    double partialSum = 0;
    for (int i = 0; i < M-1; i++) partialSum += A[i];
    for (int i = M-1; i < N; i++) {
      partialSum += A[i];
      ret[retIdx++] = partialSum/M;
      partialSum -= A[i-M+1];
    }
    return ret;
}
```

- 하나로 묶여있던 이중 for문을 분리해 반복문의 수행 횟수를 확 줄였다.
- 수행 시간은 N에 정비례하게 되고, 그래프로 그려보면 정확히 직선이 된다. 
  - 이러한 알고리즘을 **선형 시간(linear time) 알고리즘**이라고 한다. 
  - 이런 알고리즘이 대개 가장 좋은 알고리즘인 경우가 많다. 주어진 입력을 최소한 한 번씩 쳐다보기라도 하려면 선형 시간이 걸릴 수밖에 없기 때문이다!

### 🔍 선형 이하 알고리즘
**성형 전 사진 찾기**<br/>
어떤 문제 건 입력된 자료를 모두 한 번 훑는데는 입력의 크기에 비례하는 시간, 즉 선형 시간이 걸린다. 그런데 선형 이하 알고리즘은 그만큼의 시간도 걸리지 않는다는 의미인데, 어떻게 가능할까? 입력으로 주어진 자료에 대해 우리가 미리 알고 있는 지식을 활용할 수 있다면 가능해진다.

예를 들어, 어떤 연예인 A군의 코 성형 전 고등학교 사진이 공개되었다. 남들 몰래 A군의 팬인 저는 A군이 대체 언제 성형을 했는지 알고 싶어 검색엔진으로 A군의 사진 10만 장을 찾아 이들을 촬영 날짜 순으로 정렬했다. 그럼 A군이 언제 성형했는지를 가능한 한 정확하게 알려면 대체 몇 장의 사진을 확인해야 할까?
- 10만장의 사진을 모두 보는 것은 시간 낭비이므로, **남은 사진들을 항상 절반으로 나눠 가운데 있는 사진을 보는 것**이다.
  - 먼저 가운데 있는 5만 번째 사진을 확인했을때, 코를 성형하지 않은 상태라면 이 전의 사진은 볼 필요가 없다. 당연히 성형을 하지 않은 상태의 사진들일 것이니까!
  - 이로서 확인해야 할 사진이 5만장으로 줄었고, 다시 그 중 가운데 사진을 확인해 위의 과정을 동일하게 거친다. 
  - 확인할 때마다 남은 장수가 대략 절반으로 준다면, 총 몇 장의 사진을 확인해야 할까?

|확인한 사진의 수|0|1|2|...|9|10|11|12|13|14|15|16|
|---|---|---|---|---|---|---|---|---|---|
|남은 사진|100,000|50,000|25,000|...|195|97|48|24|12|6|3|1|

위 표는 확인하는 사진의 수가 증가함에 따라 남은 사진의 수가 어떻게 줄어드는지를 보여준다. 대략 17장의 사진만 확인하면 성형한 시점을 찾아낼 수 있다.
- 이를 봐야 하는 사진의 장수 N에 대해 표현하게 되면, 매번 절반씩 나누니 밑이 2인 로그 $log_2$를 사용하면 되고, 따라서 대략 $logN$이 된다.
- $log$는 굉장히 느리게 증가하는 함수이다. 이와 같이 입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 **선형 이하 시간(sublinear time) 알고리즘**이라고 한다.

**이진 탐색**<br/>
방금 전 예제에서 사용한 알고리즘을 이진 탐색(binary search)라고 한다.

> `binsearch(A[],x)` = 오름차순으로 정렬된 배열 `A[]` 와 찾고 싶은 값 `x` 가 주어질 때 `A[i-1] < x <= A[i]` 인 `i` 를 반환한다. 이때 `A[-1] = -∞` , `A[N] = ∞` 로 가정한다.

- 쉽게 생각해서, 배열 `A[]` 에서 `x` 를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환하는 함수라고 생각하면 된다. 대개의 배열이나 리스트 구현에서 `i` 번째 위치에 새 원소를 삽입한다 = `i` 번째와 그 이후의 원소들을 뒤로 한 칸씩 밀어내고 들어간다와 동일한 의미이다.
  - 따라서 `A[]` 에 `x` 가 존재한느 경우 이 함수는 첫 번째 `x` 의 위치를 반환하고, 없는 경우 `x` 보다 큰 첫 번째 원소를 반환한다.

**그래도 선형 시간 아닌가요?**<br/>
그런데 `binsearch()` 에 입력되는 배열을 만들기 위해서는 결국 모든 사진을 보면서 성형 이전인지 여부를 판단해야 한다. 게다가 그 전엔 모든 사진을 받아 시간 순으로 정렬까지 해야 한다. 따라서 전체는 선형 시간이 걸리는 게 아닌가 하는 의문이 든다. 하지만 이렇게 분석하지 않는 이유는 다음과 같다.
1. `A[]` 를 실제로 계산해서 가지고 있을 필요가 없다. 사실은 입력 배열을 넘겨준다해도, 이진 탐색 알고리즘 내부에서는 그 중 몇 개 보지도 않을 것이다. 따라서 이들을 미리 계산할 것이 아니라, 가운데 있는 것들에 대해서만 필요할 때 계산(성형 여부를 판단)하면 된다.
   - `binsearch()` 에 `A[]` 를 인자로 넘기는 것이 아닌 `i` 가 주어질 때 `A[i]` 의 값을 직접 계산하는 콜백 함수를 제공한다거나 하는 방법으로 해결 가능하다.
2. 사진을 다운받고 정렬하는 과정은 실제로 성형 전 사진을 찾는 작업과는 별개이다. 만약 A군이 코뿐만 아니라 턱까지도 성형을 했다고 하면, 이미 한 번 받아서 정렬해둔 사진이 있으면 다시 17장의 사진만 확인해서 언제 턱 성형을 했는지 알 수 있을 것이다.

**구현**<br/>
이진 탐색을 정확하게 구현하는 것은 매우 까다롭다. 이는 알고리즘의 정당성을 증명하는 방법을 다룰 때 다시 언급한다.

### 🔍 지수 시간 알고리즘
**다항 시간 알고리즘**<br/>
"반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘"들을 다항 시간 알고리즘이라고 한다.
- 다항 시간이라는 하나의 분류에 포함되는 알고리즘 간에는 엄청나게 큰 시간 차이가 날 수 있다. (다항식의 포함 범주가 매우 크기 때문)
- 다항 시간보다 더더욱 오랜 시간이 걸리는 알고리즘들이 있어 다항 시간 알고리즘을 묶었다.

**알러지가 심한 친구들**<br/>
집들이에 N명의 친구를 초대하려고 한다. 할 줄 아는 M가지 음식 중 무엇을 대접해야 할까를 고민하는데, 친구들은 각각 알러지 때문에 못 먹는 음식들이 있다. 만들 줄 아는 음식의 목록과, 해당 음식을 못 먹는 친구들의 목록이 주어질 때, 각 친구가 먹을 수 있는 음식이 최소 하나씩 있으려면 최소 몇 가지의 음식을 해야 할까?

**모든 답 후보를 평가하기**<br/>
여러 개의 답이 존재할 수 있다. 하지만 최소 개수의 답을 구하려고 할 때, 가장 간단한 방법은 모든 답을 일일이 고려해 보는 것이다.
- 만들 수 있는 음식의 모든 목록을 만드는 과정은 여러 개의 결정으로 나누면 자연스럽다.
- 첫 번째 요리를 만들지 말지 결정하고, 두 번째 요리를 만들지 말지를 결정하는 방식이다. 이렇게 점진적으로 결정하다보면, 마지막에는 존재 가능한 모든 목록을 만날 수 있다.
  - 이제 가장 적은 수의 목록을 찾는다.

이런 알고리즘을 구현하는 가장 쉬운 방법은 **재귀 호출**을 이용하는 것이다.
- 이때 재귀 함수는 한 상태를 입력받아 이 상태 밑에 달린 모든 후보들을 검사하고 이 중 가장 좋은 답을 반환하는 역할을 한다.

```java
int INF = 987654321;
int M;

private static boolean canEverybodyEat(Stack<Integer> menu) { ... }

private static int selectMenu(Stack<Integer> menu, int food) {
  if (food == M) {
    if (canEverybodyEat(menu)) return menu.length;
    return INF;
  }

  int ret = selectMenu(menu, food + 1);
  menu.push(food);
  ret = Math.min(ret, selectMenu(menu, food + 1));
  menu.pop();
  return ret;
}
```

**지수 시간 알고리즘**<br/>
위 프로그램은 모든 답을 한 번씩 다 확인하기에, 전체 걸리는 시간은 만들 수 있는 답의 수에 비례하게 된다.
- M가지의 음식마다 두 선택지가 있어 만들 수 있는 답은 모두 $2^M$가지이다.
- 그리고 답을 하나 만들 때마다 `canEverybodyEat()` 를 수행해 이 알고리즘의 수행 시간은 $2^M$에 `canEverybodyEat()` 의 수행 시간을 곱한 것이 된다.
- $2^M$과 같은 지수 함수는 알고리즘의 전체 수행 시간에 엄청난 영향을 미친다. 이와 같이 N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들은 **지수 시간(exponential time)에 동작**한다고 한다.
  - 가장 큰 수행 시간 중 하나이다.

**소인수 분해의 수행 시간**<br/>
입력으로 주어지는 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달라지는 알고리즘들 또한 지수 수행 시간을 가질 수 있다.
- 자연수 N이 주어질 때 N의 소인수 분해 결과를 반환하는 간단한 알고리즘이 있다.
- 이 알고리즘은 N이 1이 될 때까지 가능한 모든 숫자로 N을 나눠보는데, 주어진 수 N이 소수인 경우 반복문이 가장 많이 실행된다.

> 결과적으로 반복문의 실행 횟수는 N - 1이 되어, **실행 횟수가 대략 N에 비례해 최악의 경우 선형 시간이 걸린다고 생각할 수도 있다.**

이런 불일치를 직관적으로 이해하기 위해 **알고리즘의 수행 시간과 입력이 메모리에서 차지하는 공간의 관계**를 생각해보자.
- 이진 탐색, 이동 평균 계산 등 지금까지 다룬 알고리즘에서는 입력의 값들이 일정 범위 내에 있다고 어렵지 않게 가정할 수 있다.
  - 이 경우 **입력의 개수와 메모리에서 차지하는 공간이 직접적으로 비례**한다.
- 반면, 소인수 분해 문제에서는 입력으로 주어지는 숫자가 알고리즘의 동작에 직접적인 영향을 미쳐, 숫자가 특정 범위 안에 있다고 가정할 수 없다.
  - 입력의 값이 커질수록 숫자를 저장하는데 필요한 메모리의 공간도 증가할 것이다.
  - 이때 **입력이 차지하는 비트의 수에 따라 수행 시간이 증가**한다고 생각하면 아까의 불일치를 직관적으로 설명할 수 있다.

### 🔍 시간 복잡도

### 🔍 수행 시간 어림짐작하기

### 🔍 계산 복잡도 클래스: P, NP, NP-완비

## 📕 참고
**프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략** - 구종만