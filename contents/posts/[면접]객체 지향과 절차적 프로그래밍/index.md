---
title: "💬 객체 지향과 절차적 프로그래밍"
description: "개발 상식"
date: 2022-03-24
update: 2022-03-24
tags:
  - 개발상식
  - Java
  - OOP
  - PP
series: "💬 면접"
---

## 🧷 "00" 지향
- 절차 지향 : C언어
- 객체 지향 : Java, Python, C# 등

아주 틀린 말은 아니다. '지향' 이라는 것은 단순히 하나의 패러다임이지, C언어는 무조건 절차적으로만, Java는 무조건 객체지향으로만 프로그래밍해야한다는 것은 아니다.

사실 어떤 언어건 간에 절차적 프로그래밍이 가능하다. 모든 코드는 '절차적인 틀'이 있어서, 절차지향이 아닌 **절차적 프로그래밍**이라는 말이 더 맞는 말이다.

> 📌 **"OO" 지향이란 코딩하는 방식 또는 방법론의 차이이지 특정 언어가 특정 지향만 지원한다는 것은 아니다.**

또한, 객체지향 프로그래밍과 절차적 프로그래밍은 서로 반대 개념이 아닌, 상이한 개념일 뿐이다. 
- 절차적 프로그래밍은 **'데이터를 중심으로 함수'**를 만들어 쓰는 방식이고, 
- 객체 지향 프로그래밍은 **'데이터와 기능(함수)들을 묶어 하나의 객체'**를 만들어 쓰는 방식이다.

그렇다면, 왜 일반적으로 절차적 언어와 객체 지향 언어를 나누어 생각할까? 
- 이는 언어가 지원하는 기능과 특징에 있다. 구분하는 방법은 많지만 대개 아래의 기준을 충족한다면, 객체 지향적 성격이 강하다.

1. **캡슐화, 다형성, 클래스 상속을 지원하는가?**
2. **데이터 접근 제한을 걸 수 있는가?**

### 🗝 프로그래밍 패러다임의 짧막한 역사
과거에는 지금과 같은 큰 규모와 소프트웨어가 필요하지 않았다. 따라서, 과거의 프로그래밍 패러다임의 중심에는 컴퓨터가 있었다. 컴퓨터가 사고하는대로 프로그래밍하는 것이다. 하지만 점점 소프트웨어의 발전 속도가 빨라지면서, 코드도 복잡해지기 시작했다. 처음엔 C, 코볼, 포트란과 같은 절차적 언어로 구현되었던 알고리즘이 점점 더 복잡해져 결국 코드가 사람이 읽으면서 로직을 이해할 수 없게 되는 '스파게티 코드' 문제점이 대두되었다.
- 그래서 이 문제를 해결하기 위해 등장한 패러다임이 **'객체 지향적 프로그래밍'**이다.
- 이는 인간 중심적 프로그래밍으로, 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것이다. 

따라서, **절차적 프로그래밍이 객체 지향적 특징을 가져오게 된다.**
- 예를 들어 C++이 있다.
- 이는 C언어 기반에 상속, 캡슐화 등을 지원한다.
- 하지만 그렇다고 해도, 하나의 패러다임을 따를 뿐 이를 객체 지향적 언어라고는 하지 않는다.

---

## 🧷 절차적 프로그래밍(Procedure Programming)
단어 그대로 '절차적'으로 코드를 구성한다는 의미이다. 
- 데이터에 대한 순서를 파악하고, 필요한 기능을 함수로 만들어 절차적으로 진행하는 방법이다.

### 🗝 장단점
**절차적 프로그래밍의 장점**
- 객체나 클래스의 생성 없이 바로 프로그램을 작성할 수 있다.
- 필요한 기능을 함수로 만들어 사용하기에 같은 코드를 호출하여 사용할 수 있다.
- 프로그램의 흐름 이해가 쉽다.

**절차적 프로그래밍의 단점**
- 코드들이 유기적으로 연결되어 있어, 새로운 기능이나 데이터의 추가가 어렵다.
- 코드 재사용률이 떨어져 프로젝트 개발 비용과 시간이 늘어날 수 있다.
- 디버깅이 어렵다.

---

## 🧷 객체 지향 프로그래밍(Object Oriented Programming)
특정한 개념의 함수와 자료형을 함께 묶어 관리하기 위해 탄생한 개념이다. 기능들을 묶어 하나의 객체로 생성한다. 이때 추상화라는 개념을 이용해 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍에 사용한다.

### 🗝 객체 지향의 특징
1. 추상화
: 필요로 하는 속성이나 행동을 추출하는 작업
- 추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.
- 즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이다.

2. 캡슐화
: 낮은 결합도를 유지할 수 있도록 설계하는 것
- 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화시키는 것이다. (객체가 내부적으로 어떻게 구현하는지 감춤으로써)

> **결합도**
> : 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타낸다.

객체들간의 의존도가 높아지게 되면, 굳이 객체 지향으로 설계하는 의미가 없어지게 되므로, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만들어야 한다.

요구사항 변경에 대처하는 좋은 설계 방법은 객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 **응집도를 높이고 결합도를 줄여야 한다.**
- 이때, 정보 은닉을 사용하여 높은 응집도를 가지면서 낮은 결합도를 가지도록 한다.
- `private` 접근자를 사용해 외부에서 접근할 필요가 없는 것들의 접근을 제한한다.

3. 상속
일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정이다.

상속은 또 다른 캡슐화다. **자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**이라고 할 수 있다.

상속 관계에서는 단순히 하나의 클래스 안에서 속성 및 연산들의 캡슐화에 한정되지 않는다. 
- 즉, 자식 클래스 자체를 캡슐화하여 외부에 은닉하는 것으로 확장되는 것이다.

이를 통해 외부에선 이러한 클래스들에 영향 받지 않고 개발을 이어갈 수 있다는 장점이 있다.

하지만 **상속을 재사용하는 경우**에는 아래와 같은 단점들이 있다.
- 상위 클래스(부모 클래스)의 변경이 어려워진다.
  - 부모 클래스에 의존하는 자식 클래스가 많은 경우, 부모 클래스의 변경은 아래 모든 자식 클래스들의 변경을 요구하게 된다.
- 불필요한 클래스가 증가할 수 있다.
  - 유사 기능 확장 시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
- 상속이 잘못 사용될 수 있다.
  - 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다.

해결책으로는 **객체 조립(Composition)**이 있다.
- 필드에서 다른 객체를 참조하는 방식으로 구현된다.
- 상속에 비해 비교적 런타임 구조가 복잡해지고 구현이 어려운 단점이 있지만, 변경 시 유연함을 확보하는 장점이 매우 크다.

> 따라서, 같은 종류가 아닌 클래스를 상속하고 싶은 경우에는 객체 조립을 우선적으로 적용하는 것이 좋다.

상속은 **IS-A 관계가 성립할 때**나 **재사용 관점이 아닌, 기능의 확장 관점일 때** 사용하도록 한다.

4. 다형성(Polymorphism)
서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력이다. 객체 지향의 핵심과도 같다.
- 부모 클래스의 메소드를 자식 클래스가 **Overriding**해서 자신의 역할에 맞게 활용하는 것이다.

다형성은 상속과 함께 활용할 때 효율적인데, 코드를 간결하게 해주고, 유연함을 갖추게 해준다.
- 상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수만을 참조해오면 되기에 다른 클래스의 영향을 받지 않는다.

### 🗝 장단점
**객체 지향 프로그래밍의 장점**
- 모듈화, 캡슐화로 인해 디버깅과 유지보수에 용이하다.
- 객체 자체가 하나의 프로그램이기 때문에 재사용성이 높다. 자주 사용되는 로직을 라이브러리로 만들어 재사용할 수 있다.
- 객체 지향적이기 때문에 현실 세계와의 유사성에 의해 코드 이해가 쉽다.

**객체 지향 프로그래밍의 단점**
- 대부분 많은 양의 메모리를 사용하고, 속도가 느린 경향이 있다.
- 현실 세계와의 유사성에 의한 코드 이해도를 증가시키기 위해 설계에 많은 시간이 투자된다.
- 객체가 상태를 갖는다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다. 이러한 이유로 **함수형 패러다임**이 주목받고 있다.

### 🗝 객체 지향적 설계 원칙
1. **SRP(Single Responsibility Principle)** : 단일 책임 원칙
    - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.

2. **OCP(Open-Closed Principle)** : 개방-폐쇄 원칙
    - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    - 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않아야 한다.

3. **LSP(Liskov Substitution Principle)** : 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    - 상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

4. **ISP(Interface Segregation Principle)** : 인터페이스 분리 원칙
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

5. **DIP(Dependency Inversion Principle)** : 의존 역전 원칙
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 하고, 저수준 모듈이 변경되어도 고수준 모듈은 변경할 필요가 없어야 한다.

## 📕 참고
- [객체지향(OOP)과 절차적 프로그래밍(PP)](https://st-lab.tistory.com/151)
- [Object Oriented Programming](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense)
- [객체지향 프로그래밍](https://gyoogle.dev/blog/computer-science/software-engineering/Object-Oriented%20Programming.html)