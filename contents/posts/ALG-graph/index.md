---
title: "💡 Graph 이론"
description: "종만북"
date: 2021-12-28
update: 2021-12-28
tags:
  - 종만북
  - Graph
  - DFS
  - BFS
series: "💡 Algorithm"
---

# 📖 그래프

계층적인 구조보다 좀 더 일반적이고 강력한 자료 구조, 사물이나 개념 간의 연결 구조
ex. 여러 도시들을 연결하는 도로망, 사람들 간의 지인 관계, 웹 사이트 간의 링크

**트리**에 있었던 부모 자식 관계에 대한 제약이 없어 좀 더 다양하고 자유로운 구조 표현이 가능하다.

---

## 💡 정의
그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료 구조

* 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않는다.

---

## 💡 종류
표현하고자 하는 대상에 따라 여러 가지 변형된 형태를 가질 수 있다.

### 방향 그래프(directed graph) or 유향 그래프
각 간선이 “방향” 이라는 새로운 속성을 가진다. 즉, 방향에 따라 새로운 간선으로 분류된다. 
ex. 사람들 간의 짝사랑 관계, 도로에서의 일방 통행 등

> **무향 그래프(undirected graph)**
> 간선에 방향이 없는 그래프

### 가중치 그래프(weighted graph)
각 간선에 “가중치” 라는 실수 속성이 추가된다. 
ex. 두 도시 사이의 거리, 두 물건 사이의 교환 비율 등

> 최소 스패닝 트리와 최단 경로 문제에서 중요한 개념으로 사용된다!

### 다중 그래프(multigraph)
두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프

### 단순 그래프(simple graph)
두 정점 사이에 최대 한 개의 간선만 있는 그래프

> 📍 트리 or 루트 없는 트리(unrooted tree)는 부모 자식 관계가 없을 뿐, 간선들의 연결 관계만을 보면 **무향 그래프**이다.
> 즉, 간선을 통해 두 정점을 잇는 방법이 딱 하나뿐임을 의미한다.

### 이분 그래프(bipartite graph)
그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프 
ex. 하트 시그널과 같은 프로그램에서의 사랑의 작대기
* 같은 그룹의 정점들 간에는 간선이 없다.

### 사이클 없는 방향 그래프(directed acyclic graph) = DAG
한 점에서 출발해 다시 자기 자신으로 돌아오는 경로가 없는, 즉 **cycle이 없는** 방향 그래프 
ex. 여러 작업들 간의 상호 의존 관계
* 간선의 방향을 무시할 경우 cycle이 존재할 수도 있다.

---

## 💡 경로
끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것

### 단순 경로
경로 중 한 정점을 최대 한 번만 지나는 경로

### 사이클(cycle)
시작한 점에서 끝나는 경로

---

## 💡 표현 방법
여러 객체들이 서로 연결되어 있다는 점은 트리와 큰 차이가 없다.

* 각 정점을 객체로 표현
* 각 객체가 자신과 간선으로 연결된 정점들에 대한 정보의 목록을 저장

**대다수의 경우, 그래프는 트리에 비해 훨씬 정적인 용도로 사용된다.**
* 새로운 정점이나 간선을 추가하고 삭제하는 일이 자주 일어나지 않는다는 의미
* 따라서, 구조의 변경이 어렵더라도 **좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현**한다.

### 간단한 방법
1. 그래프의 정점들을 객체의 instance로 표현하는 대신 각 정점에 0부터 시작하는 번호를 붙이고,
2. 배열에 각 정점의 정보를 저장
3. 간선은 반대쪽 정점의 번호를 저장하는 방식으로 구현

### 인접 리스트
그래프의 각 정점마다 해당 정점에서 나가는 간선이 목록을 저장하는 방식
→ **그래프는 각 정점마다 하나의 연결 리스트를 갖는 방식으로 구현**

**`Java`** ⇢ List 내부에 동적 List를 선언하여 처리하고 해당 node와 cost를 List처럼 처리하는 경우가 많기 때문에, 이를 관리하기 위한 Class를 선언하여 사용한다.

```java
class Node {
	int node;
	int cost;
	
	Node (int node, int cost) {
		this.node = node;
		this.cost = cost;
	}
}
```

> **단점**
> 두 정점이 주어질 때 이 정점이 연결되어 있는지를 알기 위해서는 모든 연결 리스트를 일일이 탐색해야 한다는 것
> → 이와 같은 연산속도를 높이기 위해 **인접 행렬 (adjacency matrix)** 표현 방식을 사용

### 인접 행렬
2차원 배열을 이용해 그래프의 간선 정보를 저장 
ex. 1 → 2 ⇢ `graph[1][2] = true or cost`
→ 가장 간단한 형태의 경우, 2차원 `boolean` 값 배열

### 두 방식의 비교
두 방식은 정반대의 특징을 가져, 서로의 단점이 서로의 장점이 된다.
**메모리 공간 측면**과 **탐색 시간 측면**으로 나뉜다.

#### 인접 리스트의 장점
* |V| 개의 연결 리스트에 실제 간선 수만큼의 원소만 존재하기에 O(|V|+|E|) 크기의 공간만 사용한다.
#### 인접 리스트의 단점
* 정점의 번호가 주어진 경우, 두 정점을 잇는 간선의 존재를 알기 위해서는 모든 연결 리스트를 탐색해야 한다.
#### 인접 행렬의 장점
* 정점의 번호가 주어진 경우, 두 정점을 잇는 간선의 존재를 한 번의 배열 접근만으로 알 수 있다.
#### 인접 행렬의 단점
* 항상 정점 집합 전체를 저장하기 위한 2차원 배열을 사용하기 때문에, 항상 O(|V|^2) 크기의 공간을 사용해야 한다. 

> 간선의 수가 |V|^2에 비해 훨씬 적은 그래프: 희소 그래프(sparse graph) ⇢ 인접 리스트
> 간선의 수가 |V|^2에 거의 비례하는 그래프: 밀집 그래프(dense graph) ⇢ 인접 행렬

---

## 📖 깊이 우선 탐색 (DFS)
그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법
1. 현재 정점과 인접한 간선들을 하나씩 검사
2. 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 탐색
3. 더 이상 갈 곳이 없는 경우, 마지막에 따라왔던 간선을 따라 뒤로 돌아감

DFS에서 가장 중요한 특징은 **3번**이다.
이를 위해서 지금까지 거쳐온 정점들을 저장해야 하는데, **재귀 호출**을 이용하여 간단하게 구현할 수 있다.

> **주의할 점**
> 그래프의 모든 정점들이 간선으로 연결되지 않은 경우가 있을 수 있다.
> 이때도 모든 정점들을 볼 수 있는 코드를 작성할 수 있어야 한다.

### 💡 시간 복잡도
#### 인접 리스트를 사용하는 경우
* 한 정점마다 `DFS()` 는 한 번씩 호출 → |V| 번
* O(|V| + |E|)

#### 인접 행렬을 사용하는 경우
* `DFS()` 의 호출횟수는 인접 리스트와 동일하게 |V| 번
* 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인하므로 한 번에 O(|V|) 시간이 소모
* O(|V|^2)

### 💡 위상 정렬
의존성이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는지 계산

**의존성 그래프(dependency graph)**
각 작업을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프
→ cycle이 없는 방향 그래프, 즉 DAG

#### 위상 정렬
의존성 그래프의 모든 의존성이 만족되려면, 모든 간선이 왼쪽에서 오른쪽으로 가야 하는데, 이를 위해 **DAG의 정점을 배열하는 문제**

**직관적인 방법**
* 들어오는 간선이 하나도 없는 정점을 탐색
* 정렬 결과에 이어 붙이기
* 그래프에서 해당 정점을 삭제
위 과정을 반복

이를 `DFS` 를 이용해 해결할 수 있다.
* 한 정점에 대한 `DFS()` 가 종료될 때마다 현재 정점의 번호를 기록
* 모든 탐색이 끝난 후, 정점 번호들을 뒤집으면 위상 정렬 결과

### 💡 이론적 배경과 응용
#### 깊이 우선 탐색과 간선의 분류
깊이 우선 탐색을 수행하면 그 과정에서 그래프의 모든 간선을 한 번씩은 만나게 되는데, 일부 간선만이 처음 발견한 정점과 연결되어 있기에 이를 따라가게 된다.
! 하지만 여기서, 무시되는 간선들을 통해 그래프의 구조에 대한 정보를 알 수 있다.

어떠한 그래프에 대한 깊이 우선 탐색 시, 탐색이 따라가는 일부 간선들만 모아보면 **“트리”** 형태를 띄게 된다.
→ 이와 같이 얻어진 트리를 **깊이 우선 탐색 스패닝 트리** 혹은 **DFS 스패닝 트리** 라고 한다.

**간선의 분류**
* 트리 간선(tree edge) : 스패닝 트리에 포함된 간선
* 순방향 간선(forward edge) : 스패닝 트리의 선조에서 자손으로 연결되었지만 트리 간선이 아닌 간선
* 역방향 간선(back edge) : 스패닝 트리의 자손에서 선조로 연결되는 간선
* 교차 간선(cross edge) : 위의 세 간선이 아닌 간선, 선조와 자손 관계가 아닌 정점들 간 연결된 간선

> **어떠한 순서로 정점을 방문하느냐**에 따라 서로 다른 트리가 될 수도 있고, 간선에 대한 분류가 달라질 수도 있다.

**무향 그래프 간선의 분류**
무향 그래프의 모든 간선은 양방향으로 통행 가능하기 때문에 **교차 간선이 있을 수 없다.**
또한, 순방향 간선과 역방향 간선의 구분도 존재하지 않는다.

> **사이클 존재 여부 확인**
> 간선 구분을 이용하여 방향 그래프에서 사이클이 존재하는지 여부를 판단할 수 있다.
> → 역방향 간선의 존재 여부와 동일한 문제

##### 간선을 구분하는 방법
가장 구분하기 쉬운 간선은 트리 간선이다.
간선 (u, v)를 검사했을 때, v가 방문된 적이 없다면 이는 “트리 간선”이 된다.
하지만 v가 방문된 이후였다면, 부모인지 자손인지 알 수 있는 방법이 없다.
그래서 추가적인 정보를 저장하고 이를 통해 부모 자손 관계를 파악할 수 있어야 한다.
* 각 정점을 방문할 때, 이 정점이 방문되었다는 사실 = `visited`
* 이 정점이 몇번째로 발견되었는지 = `discovered`

**간선 (u, v)에서 u와 v의 방문 순서**
* 순방향 간선이라면, v는 u의 자손이어야 한다.
* 역방향 간선이라면, v는 u의 선조여야 한다.
* 교차 간선이라면, dfs(v)가 종료한 후 dfs(u)가 호출되어야 한다.

위 경우 중, 발견 순서 정보를 토대로 순방향 간선에 대한 구분은 가능하지만, 역방향 간선과 교차 간선에 대한 구분은 여전히 불가능하다.
그래서, **dfs(v)의 종료 여부** 또한 확인해주어야 한다.

---

## 📖 너비 우선 탐색 (BFS)
깊이 우선 탐색과 함께 가장 널리 사용되는 그래프 탐색 알고리즘으로, 다익스트라의 최단 거리 알고리즘이나 프림의 최소 스패닝 트리 알고리즘 등에 사용된다.

**”시작점에서 최소 거리 기준으로 가까운 정점부터 순서대로 방문하는 탐색 알고리즘”**

1. 각 정점을 방문할 때마다 모든 인접 정점들을 검사
2. 이 중 처음 보는 정점을 발견하면 방문 예정이라고 기록하고 별도의 위치에 저장
3. 인접한 정점을 모두 검사하고 나면, 지금까지 저장한 목록에서 다음 정점을 꺼내서 방문

> 너비 우선 탐색의 방문 순서는 **정점의 목록에서 어떤 정점을 먼저 꺼내는지에 의해 결정**

위에서 언급한 **“별도의 위치”** 는 먼저 들어온 정점을 먼저 꺼내야 하는 특성을 가져야 하므로, **`Queue`** 를 사용하여 해당 조건을 만족시킨다.

깊이 우선 탐색과 달리 너비 우선 탐색에서는 발견과 방문이 같지 않다.
따라서 모든 정점은 
* 아직 발견되지 않은 상태
* 발견되었지만 아직 방문되지는 않은 상태 (`Queue` 에 저장된 상태)
* 방문된 상태
로 3가지 상태를 가질 수 있다.

깊이 우선 탐색에서처럼, 새 정점을 발견하는 데 사용했던 간선들만을 모은 트리를 **너비 우선 탐색 스패닝 트리(BFS Spanning Tree)**라고 한다.

### 💡 시간 복잡도
모든 정점을 한 번씩 방문하며, 정점을 방문할 때마다 인접한 모든 간선을 검사하기 때문에, **깊이 우선 탐색과 동일**하다.

### 💡 너비 우선 탐색과 최단 거리
**그래프에서의 최단 경로 문제를 해결**하는데 주로 사용된다.

너비 우선 탐색 알고리즘을 간단하게 변경해 모든 정점에 대해 시작점으로부터의 거리 `distance[]` 를 계산하도록 할 수 있다.
* 탐색 과정에서 간선 (u, v)를 통해 정점 v를 처음 발견해 `Queue` 에 넣는다고 가정
* 시작점으로부터 v까지의 최단 거리 `distance[v]` 는 시작점으로부터 u까지의 최단 거리 `distance[u]` +1
이는 곧 시작점으로부터 다른 모든 정점까지의 최단 경로를 너비 우선 탐색 스패닝 트리 (BFS Spanning Tree) 에서 찾을 수 있다는 것을 의미한다.

### 💡 양방향 탐색
두 정점 사이의 최단 경로를 찾을 때 사용할 수 있는 테크닉
시작 정점에서 시작하는 **정방향 탐색**과 목표 정점에서 시작해 거꾸로 올라오는 **역방향 탐색**을 동시에 하면서, 이 둘이 가운데서 만나면 종료

이를 코드로 구현하려면,
정방향과 역방향 탐색에서 방문해야 할 정점들을 모두 같은 `Queue` 에 저장하되, 최단 거리를 저장할 때 정방향은 **양수**, 역방향은 **음수**로 저장한다.
인접한 상태 검사 시, 서로 부호가 다르다면 가운데서 만났음을 파악할 수 있다.

양방향 탐색은 너비 우선 탐색보다 훨씬 적은 정점만을 방문하고도 최단 경로를 찾을 수 있어 **메모리 사용량이 훨씬 적다.**
하지만 이를 사용할 수 없는 경우나, 목표 정점까지의 최단 거리가 너무 커서 양방향 탐색으로도 최단 경로를 찾을 수 없는 경우는 어떻게 해야 할까?

### 💡 점점 깊어지는 탐색
= Iteratively Deepening Search = IDS

* 임의의 깊이 제한 l을 정한 후 이 제한보다 짧은 경로가 존재하는지를 **깊이 우선 탐색**으로 확인
* 답을 찾으면 성공, 이를 반환
* 답을 찾지 못하면 l을 늘려서 다시 시도

이는 **“조합 탐색”**과 관련이 깊다.

### 💡 탐색 방법 선택하기
1. 상태 공간에서의 최단 경로를 찾는 경우,
**너비 우선 탐색**을 우선적으로 고려 (직관적이고 구현도 간단)
탐색의 깊이 한계가 정해져 있지 않거나 너무 깊어 메모리 사용량이 너무 크지 않은지에 대한 확인이 필요
2. 상태 공간에서의 최단 경로를 찾는데, 탐색의 최대 깊이가 정해져 있고 너비 우선 탐색을 하기에는 메모리와 시간이 부족할 경우,
**양방향 탐색**을 고려
목표 상태에서 역방향으로 움직이기가 쉬어야 한다.
3. 두 탐색이 모두 너무 메모리를 많이 사용하거나 너무 느린 경우,
최적화를 할 거리가 더 많은 **점점 깊어지는 탐색**을 사용

---

### 📕 참고
* 프로그래밍 대회에서 배우는 알고리즘 문제해결전략_구종만
* [Java그래프의 표현 :: TH](https://sskl660.tistory.com/60)