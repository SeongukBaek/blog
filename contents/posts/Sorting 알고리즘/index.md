---
title: "ğŸ’¡ Sorting ì•Œê³ ë¦¬ì¦˜"
description: "ê°œë°œ ìƒì‹"
date: 2022-04-24
update: 2022-05-05
tags:
  - ê°œë°œìƒì‹
  - Java
  - ì •ë ¬
series: "ğŸ’¡ Algorithm"
---

> Sorting ì•Œê³ ë¦¬ì¦˜ì€ í¬ê²Œ **Comparisons** ë°©ì‹ê³¼ **Non-Comparisons** ë°©ì‹ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.

## ğŸ§· Comparisons ë°©ì‹ ì•Œê³ ë¦¬ì¦˜
`Bubble Sort`, `Selection Sort`, `Insertion Sort`, `Quick Sort`, `Merge Sort`, `Heap Sort`

## ğŸ§· Non-Comparisons ë°©ì‹ ì•Œê³ ë¦¬ì¦˜
`Counting Sort`, `Radix Sort`

> **Stable sort**
> : ì¤‘ë³µëœ í‚¤ë¥¼ ìˆœì„œëŒ€ë¡œ ì •ë ¬í•˜ëŠ” ì •ë ¬ ë°©ì‹ì´ë‹¤. ì¦‰, ê°’ì´ ê°™ì€ ì›ì†Œê°€ ìˆì–´ë„ ì •ë ¬ ì‹œ ê·¸ ìˆœì„œë¥¼ ë³´ì¥í•˜ëŠ” ë°©ì‹ì´ë‹¤.
> 
> **In-place sort**
> : ì›ì†Œë“¤ì˜ ê°œìˆ˜ì— ë¹„í•´ ì¶©ë¶„íˆ ë¬´ì‹œí• ë§Œí•œ, ê±°ì˜ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì •ë ¬ ë°©ì‹ì´ë‹¤.

---

## ğŸ§· ê±°í’ˆ ì •ë ¬ (Bubble Sort)
ì„œë¡œ ì¸ì ‘í•œ ë‘ ì›ì†Œì˜ ëŒ€ì†Œë¥¼ ë¹„êµí•˜ê³ , ì¡°ê±´ì— ë§ì§€ ì•Šë‹¤ë©´ ìë¦¬ë¥¼ êµí™˜í•˜ë©° ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- ê° íšŒì „ë§ˆë‹¤, ì²« ë²ˆì§¸ ì›ì†Œì™€ ë‘ ë²ˆì§¸ ì›ì†Œë¥¼ ë¹„êµí•˜ê³ , ë‘ ë²ˆì§¸ ì›ì†Œì™€ ì„¸ ë²ˆì§¸ ì›ì†Œë¥¼ ë¹„êµí•˜ê³  êµì²´í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì „ì²´ ë°°ì—´ì„ í•œ ë²ˆ ìˆœíšŒí•œë‹¤.
  - 1íšŒì „ì˜ ê²°ê³¼ë¡œ ê°€ì¥ í° ê°’ì´ ë§¨ ë’¤ë¡œ ì´ë™í•œë‹¤.
- ë‹¤ìŒ íšŒì „ë¶€í„°ëŠ” ë§¨ ë ì›ì†ŒëŠ” ì œì™¸í•˜ê³  ì´ë¥¼ ë°˜ë³µí•œë‹¤.

```java
void bubbleSort(int[] numbers) {
  int tmp = 0;
  for (int i = 0; i < numbers.length; i++) {
    for (int j = 1; j < numbers.length - i; j++) {
      if (numbers[j - 1] > numbers[j]) {
        tmp = numbers[j - 1];
        numbers[j - 1] = numbers[j];
        numbers[j] = tmp;
      }
    }
  }
}
```

### ğŸªš ì¥ì 
- ê°„ë‹¨í•œ êµ¬í˜„ê³¼ ì§ê´€ì ì¸ ì½”ë“œ
- In-place sort
- Stable sort

### ğŸªš ë‹¨ì 
- ì •ë ¬ë˜ì–´ ìˆë˜, ì•ˆë˜ì–´ ìˆë˜, 2ê°œì˜ ì›ì†Œë¥¼ ë¹„êµí•˜ê¸° ë•Œë¬¸ì— ìµœì„ , í‰ê· , ìµœì•…ì˜ ê²½ìš° ëª¨ë‘ ì‹œê°„ ë³µì¡ë„ê°€ $O(N^2)$ ìœ¼ë¡œ ë™ì¼í•˜ë‹¤.
- êµí™˜ì´ ë§ì´ ë°œìƒí•œë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(N^2)$|$O(1)$|

> â“
> - `>=` ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤ë©´ unstable í• ê¹Œ?
>   - ê·¸ë ‡ì§€ ì•Šì„ê¹Œ?
> - ê°œì„ ì„ ìœ„í•´ì„œëŠ” ì–´ë–»ê²Œ í•´ì•¼ í•˜ëŠ”ê°€?
>   - ë¹„êµë¥¼ ìˆ˜í–‰í•˜ì§€ ì•Šì€ íšŒì „ì´ ìˆë‹¤ë©´ ë°”ë¡œ ì •ë ¬ì„ ì¢…ë£Œ!
>   - ì •ë ¬ ë²”ìœ„ë¥¼ ê³„ì† ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ì‹
>   - ì–‘ë°©í–¥ ë²„ë¸” ì •ë ¬

### ğŸªš ì–‘ë°©í–¥ ë²„ë¸” ì •ë ¬
ì •ë ¬ ë²”ìœ„ë¥¼ ê³„ì† ì—…ë°ì´íŠ¸í•˜ëŠ” ê°œì„  ë°©ì‹ì— íŒ¨ìŠ¤ì˜ ìŠ¤ìº” ë°©í–¥ì„ êµëŒ€ë¡œ ë°”ê¾¸ëŠ” ë°©ì‹ì„ ë”í•œë‹¤. ì´ë¥¼ í†µí•´ ì ì  ìŠ¤ìº”í•˜ëŠ” ë²”ìœ„ê°€ ì¤„ì–´ë“¤ê²Œ ëœë‹¤.

```java
void cocktailSort(int[] numbers) {
  int left = 0;
  int right = numbers.length - 1;
  int last = right;

  while(left < right) {
    int i;
    int tmp = 0;

    // ê°€ì¥ ì‘ì€ ì›ì†Œê°€ ë§¨ ì•ì— ìœ„ì¹˜!
    for (i = right; i > left; i--) {
      if (numbers[i - 1] > numbers[i]) {
        tmp = numbers[i - 1];
        numbers[i - 1] = numbers[i];
        numbers[i] = tmp;
        last = i;
      }
    }
    // ë§ˆì§€ë§‰ìœ¼ë¡œ êµí™˜ì´ ì¼ì–´ë‚œ ìœ„ì¹˜
    left = last;

    // ê°€ì¥ í° ì›ì†Œê°€ ë§¨ ë’¤ì— ìœ„ì¹˜
    for (i = left; i < right; i++) {
      if (numbers[i] > numbers[i + 1]) {
        tmp = numbers[i + 1];
        numbers[i + 1] = numbers[i];
        numbers[i] = tmp;
        last = i;
      }
    }
    // ë§ˆì§€ë§‰ìœ¼ë¡œ êµí™˜ì´ ì¼ì–´ë‚œ ìœ„ì¹˜
    right = last;
  }
}
```

---

## ğŸ§· ì„ íƒ ì •ë ¬ (Selection Sort)
ë²„ë¸” ì •ë ¬ê³¼ ìœ ì‚¬í•œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ, í•´ë‹¹ íšŒì „ì— ì›ì†Œë¥¼ ë„£ì„ ìœ„ì¹˜ëŠ” ì´ë¯¸ ì •í•´ì ¸ ìˆê³ , ì–´ë–¤ ì›ì†Œë¥¼ ë„£ì„ì§€ ì„ íƒí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- ê° íšŒì „ë§ˆë‹¤, ë°°ì—´ì—ì„œ ìµœì†Ÿê°’ì„ ì°¾ëŠ”ë‹¤.
- ê·¸ ê°’ì„ ë§¨ ì•ì— ìœ„ì¹˜í•œ ì›ì†Œì™€ êµì²´í•œë‹¤.
- ì´í›„ íšŒì „ë¶€í„°ëŠ” ë§¨ ì• ì›ì†Œë¥¼ ì œì™¸í•˜ê³  ë°˜ë³µí•œë‹¤.

> Insertion sortì™€ ë‹¤ë¥¸ ì ì€, ë°°ì—´ì—ì„œ í•´ë‹¹ ìë¦¬ë¥¼ ì„ íƒí•˜ê³ , ê·¸ ìë¦¬ì— ì˜¬ ê°’ì„ ë°°ì—´ì—ì„œ ì„ íƒí•˜ì—¬ ìœ„ì¹˜ì‹œí‚¤ëŠ” ë°©ì‹ì´ë‹¤.

```java
void selectionSort(int[] numbers) {
  int tmp = 0;
  for (int i = 0; i < numbers.length - 1; i++) {
    // ì •ë ¬ë  ì›ì†Œë¥¼ ë„£ì„ ìœ„ì¹˜ ì§€ì •, ì™¼ìª½ì—ì„œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ìˆ˜í–‰
    int minIndex = i;
    // ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ì¸ë±ìŠ¤ íƒìƒ‰
    for (int j = i + 1; j < numbers.length; j++) {
      if (numbers[j] < numbers[minIndex])
        minIndex = j;
    }
    tmp = numbers[minIndex];
    numbers[minIndex] = numbers[i];
    numbers[i] = tmp;
  }
}
```

### ğŸªš ì¥ì 
- ê°„ë‹¨í•œ êµ¬í˜„
- ì •ë ¬ì„ ìœ„í•œ ë¹„êµ íšŸìˆ˜ëŠ” ë§ì§€ë§Œ, ë²„ë¸” ì •ë ¬ì— ë¹„í•´ ì‹¤ì œë¡œ êµí™˜í•˜ëŠ” íšŸìˆ˜ëŠ” ì ë‹¤.
- In-place sort

### ğŸªš ë‹¨ì 
- ë§¤ íšŒì „ë§ˆë‹¤, ì •ë ¬ëœ ì›ì†Œë¥¼ ì œì™¸í•˜ê³  ëª¨ë“  ì›ì†Œì— ëŒ€í•´ ë¹„êµë¥¼ ìˆ˜í–‰í•´ì•¼ í•œë‹¤. ìµœì„ , í‰ê· , ìµœì•…ì˜ ê²½ìš° ëª¨ë‘ ì‹œê°„ ë³µì¡ë„ê°€ $O(N^2)$ ìœ¼ë¡œ ë™ì¼í•˜ë‹¤.
- Unstable sort

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(N^2)$|$O(1)$|

> â“ 
> - stableí•˜ê²Œ í•˜ëŠ” ë°©ë²•ì€?
>   - ìµœì†Ÿê°’ê³¼ì˜ êµí™˜ì´ ì•„ë‹Œ, ë‚˜ë¨¸ì§€ ì›ì†Œë“¤ì„ í•œ ìë¦¬ì”© ë’¤ë¡œ ë¯¸ëŠ” ë°©ì‹ìœ¼ë¡œ stableí•˜ê²Œ í•  ìˆ˜ ìˆë‹¤.

---

## ğŸ§· ì‚½ì… ì •ë ¬ (Insertion Sort)
ì„ íƒ ì •ë ¬ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ, ì¢€ ë” íš¨ìœ¨ì ì¸ ë°©ì‹ì´ë‹¤. `i` ë²ˆì§¸ë¥¼ ì •ë ¬í•  ìˆœì„œë¼ê³  ê°€ì •í•˜ë©´, `0` ë¶€í„° `i - 1` ë²ˆì§¸ ì›ì†Œë“¤ì€ ì •ë ¬ë˜ì–´ìˆë‹¤ëŠ” ê°€ì •í•˜ì—, `i` ë²ˆì§¸ ì›ì†Œì™€ `i - 1` ë²ˆì§¸ ì›ì†Œë¶€í„° `0` ë²ˆì§¸ ì›ì†Œê¹Œì§€ ë¹„êµí•˜ë©´ì„œ í° ê²½ìš°ì—ë§Œ êµí™˜í•œë‹¤.
- 2ë²ˆì§¸ ìœ„ì¹˜ì˜ ê°’ì„ `tmp` ì— ì €ì¥í•œë‹¤. (1ë²ˆì§¸ ì›ì†ŒëŠ” ì •ë ¬ë˜ì—ˆë‹¤ê³  ê°€ì •)
- `tmp` ì™€ ì´ì „ì— ìˆëŠ” ì›ì†Œë“¤ê³¼ ë¹„êµí•˜ë©° ì‚½ì…í•´ë‚˜ê°„ë‹¤. ì´ì „ì˜ ì›ì†Œë“¤ë³´ë‹¤ `tmp` ì— ìˆëŠ” ê°’ì´ ì‘ì€ ê²½ìš° êµí™˜í•œë‹¤.
  - í•œ íšŒì „ì´ ëë‚˜ê³  ë‚˜ë©´, `tmp` ì•  ìˆëŠ” ê°’ì„ ìœ„ì¹˜ì‹œí‚¨ë‹¤.
- ë‹¤ìŒ ìœ„ì¹˜ì˜ ê°’(2ë²ˆì§¸ ì´í›„)ì„ `tmp` ì— ì €ì¥í•˜ê³  ì´ë¥¼ ë°˜ë³µí•œë‹¤.

```java
void insertionSort(int[] numbers) {
  for (int i = 1; i < numbers.length; i++) {
    int tmp = numbers[i];
    int prev = i - 1;
    // ì´ì „ ìœ„ì¹˜ê¹Œì§€ì˜ ì›ì†Œë“¤ ì¤‘ í˜„ì¬ ì‚½ì…í•  ê°’ë³´ë‹¤ ì‘ì€ ê°’ì´ ë‚˜ì˜¬ ë–„ê¹Œì§€ ì¸ë±ìŠ¤ë¥¼ ì˜®ê¹€
    while(prev >= 0 && numbers[prev] > tmp) {
      numbers[prev + 1] = numbers[prev];
      prev--;
    }
    numbers[prev + 1] = tmp;
  }
}
```

### ğŸªš ì¥ì 
- ë‹¨ìˆœí•œ ì•Œê³ ë¦¬ì¦˜
- ëŒ€ë¶€ë¶„ì˜ ì›ì†Œê°€ ì´ë¯¸ ì •ë ¬ëœ ìƒíƒœë¼ë©´, ë§¤ìš° íš¨ìœ¨ì ì¼ ìˆ˜ ìˆë‹¤.
- In-place sort
- Stable sort
- ìµœì„ ì˜ ê²½ìš°(ëª¨ë‘ ì •ë ¬ëœ ê²½ìš°, 1ë²ˆì”©ë§Œ ë¹„êµë¥¼ ìˆ˜í–‰) $O(N)$ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ê¸°ì—, ì„ íƒ ì •ë ¬ì´ë‚˜ ë²„ë¸” ì •ë ¬ë³´ë‹¤ëŠ” ìƒëŒ€ì ìœ¼ë¡œ ë¹ ë¥´ë‹¤.
- Online ì•Œê³ ë¦¬ì¦˜

> **Online alg**
> : ì‹œì‘í•˜ëŠ” ì‹œì ì— ëª¨ë“  ì •ë³´ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šê³ , ì…ë ¥ì„ ì°¨ë¡€ë¡œ ë°›ìœ¼ë©´ì„œ ì²˜ë¦¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

### ğŸªš ë‹¨ì 
- í‰ê· ê³¼ ìµœì•…ì˜ ì‹œê°„ë³µì¡ë„ê°€ $O(N^2)$ì´ë‹¤.
- ë°°ì—´ì˜ ê¸¸ì´ê°€ ê¸¸ì–´ì§ˆìˆ˜ë¡ ë¹„íš¨ìœ¨ì ì´ë‹¤.

> **ì„ íƒ ì •ë ¬ê³¼ì˜ ë¹„êµ**
> - kë²ˆì§¸ ë°˜ë³µ ì´í›„, ì²« ë²ˆì§¸ k ìš”ì†Œê°€ ì •ë ¬ëœ ìˆœì„œë¡œ ì˜¨ë‹¤ëŠ” ì ì—ì„œ ìœ ì‚¬í•˜ì§€ë§Œ, ì„ íƒ ì •ë ¬ì€ k + 1ë²ˆì§¸ ìš”ì†Œë¥¼ ì°¾ê¸° ìœ„í•´ ë‚˜ë¨¸ì§€ ëª¨ë“  ìš”ì†Œë¥¼ íƒìƒ‰í•´ì•¼ í•œë‹¤.
> - ì‚½ì… ì •ë ¬ì´ ë” íš¨ìœ¨ì ì¸ ì´ìœ ì´ë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(N^2)$|$O(1)$|

---

## ğŸ§· í€µ ì •ë ¬ (Quick Sort)
ë¶„í•  ì •ë³µì„ í†µí•´ ì£¼ì–´ì§„ ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë°©ì‹ì´ë‹¤.
- ë°°ì—´ ê°€ìš´ë°ì„œ í•˜ë‚˜ì˜ ì›ì†Œë¥¼ ì„ íƒí•œë‹¤. (Pivotì´ë¼ ì¹­í•œë‹¤.)
- í”¼ë´‡ ì•ì—ëŠ” í”¼ë´‡ë³´ë‹¤ ê°’ì´ ì‘ì€ ëª¨ë“  ì›ì†Œë“¤ì´ ìœ„ì¹˜í•˜ê³ , í”¼ë´‡ ë’¤ì—ëŠ” í”¼ë´‡ë³´ë‹¤ ê°’ì´ í° ëª¨ë“  ì›ì†Œë“¤ì´ ìœ„ì¹˜í•˜ë„ë¡ í”¼ë´‡ì„ ê¸°ì¤€ìœ¼ë¡œ ë°°ì—´ì„ ë‘˜ë¡œ ë¶„í• í•œë‹¤. 
  - ë¶„í• ì„ ë§ˆì¹œ ë’¤ í”¼ë´‡ì€ ë” ì´ìƒ ì›€ì§ì´ì§€ ì•ŠëŠ”ë‹¤.
- ë¶„í• ëœ ë‘ ê°œì˜ ì‘ì€ ë°°ì—´ì— ëŒ€í•´ ì¬ê·€ì ìœ¼ë¡œ ìœ„ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

> **ë¶„í•  ì •ë³µ(Divide & Conquer)**
> : ë¬¸ì œë¥¼ ì‘ì€ 2ê°œì˜ ê²¹ì¹˜ì§€ ì•ŠëŠ” ë¬¸ì œë¡œ ë¶„ë¦¬í•˜ì—¬ ê°ê°ì„ í•´ê²°í•œ ë‹¤ìŒ, ê²°ê³¼ë¥¼ ëª¨ì•„ì„œ ì›ë˜ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì „ëµ

```java
// ë¶€ë¶„ ë°°ì—´ì„ ì •ë ¬í•œë‹¤. ë¶€ë¶„ ë°°ì—´ì˜ í¬ê¸°ê°€ ì¶©ë¶„íˆ ì‘ì§€ ì•Šì€ ê²½ìš° ìˆœí™˜ í˜¸ì¶œí•˜ì—¬ ë¶„í•  ì •ë³µí•œë‹¤.
void quickSort(int[] numbers, int left, int right) {
  if (left >= right) return;

  int pivot = partition(numbers, left, right);

  quickSort(numbers, left, pivot - 1);
  quickSort(numbers, pivot, right);
}

// ë°°ì—´ì„ í”¼ë´‡ ê¸°ì¤€ìœ¼ë¡œ ë¹„ê· ë“±í•˜ê²Œ 2ê°œì˜ ë¶€ë¶„ ë°°ì—´ë¡œ ë¶„í• í•œë‹¤.
int partition(int[] numbers, int left, int right) {
  int pivot = numbers[left];
  int i = left, j = right;
  int tmp = 0;

  while(i < j) {
    while(pivot < numbers[j]) j--;
    while(i < j && pivot >= numbers[i]) i++;
    tmp = numbers[i];
    numbers[i] = numbers[j];
    numbers[j] = tmp;
  }
  numbers[left] = numbers[i];
  numbers[i] = pivot;

  return i;
}
```

### ğŸªš ê°œì„ 
`partition()` í•¨ìˆ˜ì—ì„œ í”¼ë´‡ ê°’ì´ ìµœì†Œë‚˜ ìµœëŒ€ê°’ìœ¼ë¡œ ì§€ì •ë˜ì–´ ë¶€ë¶„ ë°°ì—´ë¡œ ë‚˜ëˆ ì§€ì§€ ì•Šì•˜ì„ ë•Œ, $O(N^2)$ ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.
- ì¦‰, ì´ë¯¸ ë°°ì—´ì´ ì •ë ¬ëœ ê²½ìš° ìµœì•…ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.
- ë°°ì—´ì—ì„œ ê°€ì¥ ì•ì— ìˆëŠ” ê°’ê³¼ ì¤‘ê°„ê°’ì„ êµí™˜í•´ì¤€ë‹¤ë©´, ì‹œê°„ ë³µì¡ë„ë¥¼ $O(NlogN)$ ìœ¼ë¡œ ê°œì„ í•  ìˆ˜ ìˆë‹¤.(ìµœì•…ì˜ ì‹œê°„ ë³µì¡ë„ê°€ ë˜ëŠ” ê²ƒì€ ì•„ë‹˜!)

### ğŸªš ì¥ì 
- ìµœì„ ì˜ ê²½ìš°(ë§¤ í”¼ë´‡ì´ ì •í™•í•˜ê²Œ ë‘ ë¶€ë¶„ ë°°ì—´ë¡œ ë¶„í• í•˜ëŠ” ê²½ìš°), ì‹œê°„ ë³µì¡ë„ê°€ $O(NlogN)$ ì´ë‹¤. (ê° ìˆœí™˜ í˜¸ì¶œ ë‹¨ê³„ì˜ ë¹„êµ ì—°ì‚°ì€ `N` ë²ˆ, ì´ ë¹„êµ íšŸìˆ˜ëŠ” `logN` ë²ˆ)
- ë¶ˆí•„ìš”í•œ ë°ì´í„°ì˜ ì´ë™ì„ ì¤„ì´ê³ , ë¨¼ ê±°ë¦¬ì˜ ë°ì´í„°ë¥¼ êµí™˜í•  ë¿ë§Œ ì•„ë‹ˆë¼, í•œ ë²ˆ ê²°ì •ëœ í”¼ë´‡ë“¤ì´ ì¶”í›„ ì—°ì‚°ì—ì„œ ì œì™¸ë˜ëŠ” íŠ¹ì„±ìœ¼ë¡œ, ì‹œê°„ ë³µì¡ë„ê°€ $O(NlogN)$ ì¸ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ê°€ì¥ ë¹ ë¥¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- In-place sort

### ğŸªš ë‹¨ì 
- ìµœì•…ì˜ ê²½ìš°(ì´ë¯¸ ë°°ì—´ì´ ì •ë ¬ëœ ê²½ìš°), ì‹œê°„ ë³µì¡ë„ê°€ $O(N^2)$ ì´ë‹¤.
- Unstable sort

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(NlogN)$|$O(1)$|

> Javaì˜ `Arrays.sort()` ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ Dual Pivot Quick Sortë¥¼ ì‚¬ìš©í•œë‹¤.
> - ì‚½ì… ì •ë ¬ê³¼ í€µ ì •ë ¬ì„ í•©ì¹œ ê°œë…ì´ë‹¤.
> - ë§ ê·¸ëŒ€ë¡œ í”¼ë´‡ì„ 2ê°œ ì‚¬ìš©í•˜ê³ , ì´ 3ê°œì˜ êµ¬ì—­ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì •ë ¬í•œë‹¤.

---

## ğŸ§· ë³‘í•© ì •ë ¬ (Merge Sort)
í•©ë³‘ ì •ë ¬ì´ë¼ê³ ë„ í•˜ë©°, ì´ ë˜í•œ ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤.
- ì˜ì—­ì„ ìª¼ê°¤ ìˆ˜ ìˆì„ ë§Œí¼ ìª¼ê°  í›„, í•©ë³‘ì‹œí‚¤ë©´ì„œ ì •ë ¬í•´ë‚˜ê°„ë‹¤.

```java
void mergeSort(int[] numbers, int left, int right) {
  if (left < right) {
    int mid = (left + right) / 2;

    // mergeSort()ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ê³„ì† í˜¸ì¶œí•¨ìœ¼ë¡œì¨, ìª¼ê°œì§ˆ ë•Œê¹Œì§€ ê³„ì† ìª¼ê°¬
    mergeSort(numbers, left, mid);
    mergeSort(numbers, mid + 1, right);
    merge(numbers, left, mid, right);
  }
}

// ì •ë ¬ëœ ë‘ ë¶€ë¶„ ë°°ì—´ì„ ìˆœì°¨ì ìœ¼ë¡œ ë¹„êµí•˜ë©´ì„œ ë³‘í•©
void merge(int[] numbers, int left, int mid, int right) {
  int[] L = Arrays.copyOfRange(numbers, left, mid + 1);
  int[] R = Arrays.copyOfRange(numbers, mid + 1, right + 1);

  int i = 0, j = 0, k = left;
  int lenL = L.length, lenR = R.length;

  while(i < lenL && j < lenR) {
    if (L[i] <= R[j]) numbers[k] = L[i++];
    else numbers[k] = R[j++];
    k++;
  }

  while(i < lenL) numbers[k++] = L[i++];
  while(j < lenR) numbers[k++] = R[j++];
}
```

> ìˆœì°¨ì ì¸ ë¹„êµë¥¼ í†µí•´ ì •ë ¬ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— `LinkedList` ì˜ ì •ë ¬ì´ í•„ìš”í•  ë•Œ íš¨ìœ¨ì ì´ë‹¤.
> - í€µ ì •ë ¬ì€ ì„ì˜ ì ‘ê·¼ì´ê¸° ë•Œë¬¸ì— `LinkedList` ì— ëŒ€í•´ì„œëŠ” ì„±ëŠ¥ì´ ì¢‹ì§€ ì•Šë‹¤.

> **í€µ ì •ë ¬ê³¼ ë³‘í•© ì •ë ¬ì˜ ì°¨ì´ì **
> - í€µ ì •ë ¬: ìš°ì„  í”¼ë´‡ì„ í†µí•´ ì •ë ¬í•œ í›„ ì˜ì—­ì„ ìª¼ê°¬
> - ë³‘í•© ì •ë ¬: ì˜ì—­ì„ ìª¼ê°¤ ìˆ˜ ìˆì„ ë§Œí¼ ìª¼ê°  í›„ ì •ë ¬

### ğŸªš ì¥ì 
- ìµœì„ , ìµœì•…, í‰ê· ì˜ ê²½ìš° ëª¨ë‘ ì‹œê°„ ë³µì¡ë„ê°€ $O(NlogN)$ ì´ë‹¤.
- Stable sort

### ğŸªš ë‹¨ì 
- ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì´ ë” í•„ìš”í•˜ë‹¤.
  - In-place sortì´ ì•„ë‹ˆë‹¤.
  - `LinkedList` ë¥¼ ì‚¬ìš©í•˜ë©´ In-place í•˜ê²Œ í•  ìˆ˜ ìˆë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(NlogN)$|$O(N)$|

---

## ğŸ§· í™ ì •ë ¬ (Heap Sort)
ì™„ì „ ì´ì§„ íŠ¸ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” í™ì„(`Binary Heap`) ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” ì •ë ¬ ë°©ì‹
- `Binary Heap` ì„ í™œìš©í•œ ì •ë ¬ ë°©ì‹ì€ 2ê°€ì§€ê°€ ìˆë‹¤.
  - ì •ë ¬ ëŒ€ìƒì¸ ë°ì´í„°ë“¤ì„ í™ì— ë„£ì—ˆë‹¤ê°€, êº¼ë‚´ëŠ” ì›ë¦¬ë¡œ ì •ë ¬ (inplace sort X)
  - ê¸°ì¡´ ë°°ì—´ì„ `heapify`(`heap` ìœ¼ë¡œ ë§Œë“œëŠ” ê³¼ì •)ì„ ê±°ì³ êº¼ë‚´ëŠ” ì›ë¦¬ë¡œ ì •ë ¬ (inplace sort O)
- **ìµœëŒ€ í™**ì„ êµ¬ì„±í•œë‹¤.
- ì¦‰, í˜„ì¬ í™ì˜ ë£¨íŠ¸ì—ëŠ” ìµœëŒ“ê°’ì´ ì¡´ì¬í•˜ê²Œ ëœë‹¤. ë£¨íŠ¸ì˜ ê°’ì„ ë§ˆì§€ë§‰ ë…¸ë“œì™€ ë°”ê¾¼ í›„, í™ ì‚¬ì´ì¦ˆë¥¼ 1 ì¤„ì¸ë‹¤.
- í™ì˜ ì‚¬ì´ì¦ˆê°€ 1ë³´ë‹¤ í° ê²½ìš°ì— ëŒ€í•´ ìœ„ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.
- ë§¤ ê³¼ì •ë§ˆë‹¤ ìµœëŒ“ê°’ì„ ë§¨ ë’¤ì— ìœ„ì¹˜ì‹œí‚¤ë©´ì„œ ì •ë ¬í•œë‹¤.

> **ì™„ì „ ì´ì§„ íŠ¸ë¦¬?**
> : ì‚½ì…í•  ë•Œ ì™¼ìª½ë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì¶”ê°€í•˜ëŠ” ì´ì§„ íŠ¸ë¦¬ë¡œ, ë§ˆì§€ë§‰ ë ˆë²¨ì„ ì œì™¸í•œ ëª¨ë“  ë ˆë²¨ì€ ì±„ì›Œì ¸ ìˆì–´ì•¼ í•œë‹¤.

> **ìµœëŒ€ í™, ìµœì†Œ í™**
> - ìµœëŒ€ í™ : ê° ë…¸ë“œì˜ ê°’ì´ í•´ë‹¹ `children` ì˜ ê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬
> - ìµœì†Œ í™ : ê° ë…¸ë“œì˜ ê°’ì´ í•´ë‹¹ `children` ì˜ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì™„ì „ ì´ì§„ íŠ¸ë¦¬

```java
void heapSort(int[] array) {
  int n = array.length;
  
  // ìµœëŒ€ í™ êµ¬ì„±
  for (int i = n / 2 - 1; i >= 0; i--)
    heapify(array, n, i);
  
  // ìµœëŒ€ ê°’ ì¶”ì¶œ í›„, ë‹¤ì‹œ ìµœëŒ€ í™ êµ¬ì„± ë°˜ë³µ
  for (int i = n - 1; i > 0; i--) {
    swap(array, 0, i);
    heapify(array, i, 0);
  }
}

void heapify(int[] array, int n, int i) {
  int p = i;
  // ë¶€ëª¨ ë…¸ë“œ ê¸°ì¤€ìœ¼ë¡œ, ì™¼ìª½ ìì‹ ë…¸ë“œì™€ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ idx ì§€ì •
  int l = i * 2 + 1;
  int r = i * 2 + 2;
  
  // ì™¼ìª½ ìì‹ë…¸ë“œ
  if (l < n && array[p] < array[l])
    p = l;

  // ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œ
  if (r < n && array[p] < array[r])
    p = r;
  
  // ë¶€ëª¨ë…¸ë“œ < ìì‹ë…¸ë“œ
  if(i != p) {
    swap(array, p, i);
    heapify(array, n, p);
  }
}
```

### ğŸªš ì¥ì 
- ìµœì„ , ìµœì•…, í‰ê· ì˜ ê²½ìš° ëª¨ë‘ ì‹œê°„ ë³µì¡ë„ê°€ $O(NlogN)$ì´ë‹¤.
  - `heap` ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ì‹œê°„ ë³µì¡ë„: $O(logN)$
  - `heap` ì—ì„œ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ëŠ” ì‹œê°„ ë³µì¡ë„: $O(logN)$
- ê°€ì¥ í¬ê±°ë‚˜ ê°€ì¥ ì‘ì€ ê°’ì„ êµ¬í•  ë•Œ, ìµœëŒ€ k ë§Œí¼ ë–¨ì–´ì§„ ìš”ì†Œë“¤ì„ ì •ë ¬í•  ë•Œ í™œìš©í•œë‹¤ë©´ íš¨ìœ¨ì ì´ë‹¤.
  - ìµœì†Œ í™ or ìµœëŒ€ í™ì˜ ë£¨íŠ¸ ê°’ì´ê¸° ë•Œë¬¸ì— **í•œ ë²ˆì˜ í™ êµ¬ì„±**ì„ í†µí•´ êµ¬í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ê³ , ì‚½ì… ì •ë ¬ë³´ë‹¤ ë”ìš± ê°œì„ ëœ ê²°ê³¼ë¥¼ ì–»ì–´ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

### ğŸªš ë‹¨ì 
- Unstable sort
- ë°ì´í„°ì˜ ìƒíƒœì— ë”°ë¼ ê°™ì€ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ëŠ” ë‹¤ë¥¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì— ë¹„í•´ ëŠë¦¬ë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(NlogN)$|$O(N)$|

---

> ì•„ë˜ 2ê°€ì§€ì˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ë¹„êµë¥¼ ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ” **`non-Comparisons Sorting Algorithm`** ì´ë‹¤.

## ğŸ§· ê¸°ìˆ˜ ì •ë ¬ (Radix Sort)
ë°ì´í„°ë¥¼ êµ¬ì„±í•˜ëŠ” ê¸°ë³¸ ìš”ì†Œ(ê¸°ìˆ˜: Radix)ë¥¼ ì´ìš©í•˜ëŠ” ì •ë ¬ ë°©ì‹
- ë‚®ì€ ìë¦¿ìˆ˜ë¶€í„° ë¹„êµí•˜ì—¬ í•˜ë‚˜ì˜ ë²„í‚·ì„ ìƒì„±í•´ ë¶„ë¥˜í•˜ê³ , ê·¸ ë‹¤ìŒ ìë¦¿ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ë¥¼ ë°˜ë³µí•œë‹¤.
- **LSD(Least Significant Digit) ë°©ì‹**ê³¼ **MSD(Most Significant Digit) ë°©ì‹**ì´ ìˆë‹¤.
  - LSD ë°©ì‹ì€ ëœ ì¤‘ìš”í•œ ìˆ«ìë¶€í„° ì •ë ¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ, ì¼ì˜ ìë¦¬ë¶€í„° ì •ë ¬í•œë‹¤.
  - MSD ë°©ì‹ì€ ì¤‘ìš”í•œ ìˆ«ìë¶€í„° ì •ë ¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ, ê°€ì¥ í° ìë¦¿ìˆ˜ë¶€í„° ì •ë ¬í•œë‹¤.

> â“ **ë‚®ì€ ìë¦¿ìˆ˜ë¶€í„° ì •ë ¬í•˜ëŠ” ì´ìœ  (MSDì™€ LSDì˜ ë¹„êµ)**
> - LSDëŠ” ì¤‘ê°„ì— ì •ë ¬ ê²°ê³¼ë¥¼ ë³¼ ìˆ˜ ì—†ë‹¤. ì¼ì˜ ìë¦¬ë¶€í„° ë°±ì˜ ìë¦¬ê¹Œì§€ ì •ë ¬ì„ ë§ˆì¹œ í›„ ê²°ê³¼ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤.
> - MSDëŠ” ì¤‘ê°„ì— ì •ë ¬ ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ì •ë ¬í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ë‹¨ì¶•ì‹œí‚¬ ìˆ˜ ìˆë‹¤.
>   - í•˜ì§€ë§Œ ì´ë•Œ, ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ê³ , ì´ë•Œ ë©”ëª¨ë¦¬ë¥¼ ë” ì‚¬ìš©í•˜ê²Œ ëœë‹¤.
> 
> ê²°ë¡ ì ìœ¼ë¡œ, **LSDê°€ MSDë³´ë‹¤ ë” ì¼ê´€ëœ ì•Œê³ ë¦¬ì¦˜**ì´ë¯€ë¡œ, ëŒ€ê°œ **ê¸°ìˆ˜ ì •ë ¬ì„ ë…¼í•  ë•ŒëŠ” LSDë¥¼ ë…¼í•œë‹¤.**

> ì…ë ¥ ë°ì´í„°ì˜ ìµœëŒ“ê°’ì— ë”°ë¼ ì •ë ¬í•˜ëŠ” `Counting Sort` ì˜ ë¹„íš¨ìœ¨ì„±ì„ ê°œì„ í•˜ê¸° ìœ„í•´ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.
> - ìë¦¿ìˆ˜ì˜ ê°’ ë³„ë¡œ ì •ë ¬ì„ í•˜ê¸°ì— ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ê°’ì˜ ìµœëŒ€ ì‚¬ì´ì¦ˆëŠ” 0 ~ 9(10)ì´ë‹¤.

<img src="https://blog.kakaocdn.net/dn/DWH0S/btqFOYnIbCu/Q7HOAOzzvlD4xW279LqTLK/img.gif" width="80%">

```java
void radixSort(int[] arr, int n) {
  // ìµœëŒ“ê°’ ì°¾ê¸°
  int m = Arrays.stream(arr).max().getAsInt();
  
  // ìµœëŒ“ê°’ì„ ë‚˜ëˆ´ì„ ë•Œ, 0ì´ ë‚˜ì˜¤ë©´ ëª¨ë“  ìˆ«ìê°€ expì˜ ì•„ë˜
  for (int exp = 1; m / exp > 0; exp *= 10)
    countSort(arr, n, exp);
}

void countSort(int[] arr, int n, int exp) {
  int[] buffer = new int[n];
  int[] count = new int[10];
  int i = 0;
  
  // expì˜ ìë¦¿ìˆ˜ì— í•´ë‹¹í•˜ëŠ” count ì¦ê°€
  for (i = 0; i < n; i++) {
    count[(arr[i] / exp) % 10]++;
  }

  // ëˆ„ì í•© êµ¬í•˜ê¸°
  for (i = 1; i < 10; i++) {
    count[i] += count[i - 1];
  }

  // ì¼ë°˜ì ì¸ Counting sort ê³¼ì •
  for (i = n - 1; i >= 0; i--) {
    int idx = (arr[i] / exp) % 10;
    buffer[count[idx] - 1] = arr[i];
    count[idx]--;
  }

  for (i = 0; i < n; i++) {
    arr[i] = buffer[i];
  }
}
```

### ğŸªš ì¥ì 
- ë¬¸ìì—´ê³¼ ì •ìˆ˜ì˜ ì •ë ¬ì´ ê°€ëŠ¥í•˜ë‹¤.
- Stable sort

### ğŸªš ë‹¨ì 
- ìë¦¿ìˆ˜ê°€ ì—†ëŠ” ë°ì´í„°ì— ëŒ€í•œ ì •ë ¬ì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. (ex. ë¶€ë™ ì†Œìˆ«ì )
- ì¤‘ê°„ ê²°ê³¼ë¥¼ ì €ì¥í•  ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì´ í•„ìš”í•˜ë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(N)$|$O(N)$|

---

## ğŸ§· ê³„ìˆ˜ ì •ë ¬ (Counting Sort)
ë§ ê·¸ëŒ€ë¡œ, ëª‡ ê°œì¸ì§€ ê°œìˆ˜ë¥¼ ì„¸ì–´ ì •ë ¬í•˜ëŠ” ë°©ì‹ì´ë‹¤.
- ì£¼ì–´ì§„ ë°ì´í„° ì¤‘ ê°€ì¥ í° ê°’ì„ sizeë¡œ í•˜ëŠ” ë°°ì—´ì„ ìƒì„±í•œë‹¤.
- ë°°ì—´ì„ íƒìƒ‰í•˜ë©°, ë°ì´í„°ì˜ ë“±ì¥ íšŸìˆ˜ë¥¼ í•´ë‹¹ indexì— ì €ì¥í•œë‹¤.
- ì´í›„ ì™„ì„±ëœ ë“±ì¥ íšŸìˆ˜ ë°°ì—´ì„ ëˆ„ì í•©ìœ¼ë¡œ ë³€ê²½í•œë‹¤.
- ì£¼ì–´ì§„ ë°ì´í„° ë°°ì—´ì„ ë’¤ì—ì„œë¶€í„° íƒìƒ‰í•˜ë©°, `ë“±ì¥ íšŸìˆ˜ ë°°ì—´[ì£¼ì–´ì§„ ë°ì´í„° ë°°ì—´ì˜ ê°’]` ì— í•´ë‹¹ ìˆ«ìë¥¼ ìœ„ì¹˜ì‹œí‚¨ë‹¤.
  - ê·¸ë¦¬ê³  ëˆ„ì í•© ë°°ì—´ì˜ ê°’ì„ 1ì”© ê°ì†Œì‹œí‚¨ë‹¤.

<img src="https://t1.daumcdn.net/cfile/tistory/22538A4D56D2FFBA2E" width="80%">

<img src="https://t1.daumcdn.net/cfile/tistory/23057D4956D2FFE314" width="80%">

```java
void countingSort(int[] numbers) {
  int[] sortedArr = new int[numbers.length];
  int[] counting = new int[Arrays.stream(numbers).max().getAsInt() + 1];

  // ë“±ì¥ íšŸìˆ˜ ê³„ì‚°
  for (int num : numbers)
    counting[num]++;

  // ëˆ„ì í•© ê³„ì‚°
  for (int i = 1; i < counting.length; i++)
    counting[i] += counting[i - 1];

  // ëˆ„ì í•© ë°°ì—´ê³¼ ì£¼ì–´ì§„ ë°ì´í„°ë¥¼ ì´ìš©í•´ ì •ë ¬ ìˆ˜í–‰
  for (int i = numbers.length - 1; i >= 0; i--) {
    sortedArr[counting[numbers[i]] - 1] = numbers[i];
    counting[numbers[i]]--;
  }

  System.out.println(Arrays.toString(sortedArr));
}
```

### ğŸªš ì¥ì 
- ìµœì„ ì˜ ê²½ìš° $O(N)$ì˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì ¸, ê°€ì¥ ë¹ ë¥¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- Stable sort
- ì •ë ¬í•  ë°ì´í„°ê°€ íŠ¹ì •í•œ ë²”ìœ„ ì•ˆì— ìˆëŠ” ê²½ìš° ìì£¼ ì‚¬ìš©í•œë‹¤.
  - ëŒ€í‘œì ìœ¼ë¡œëŠ” 26ê°œì˜ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì—ì„œ `Suffix Array` ë¥¼ ì–»ëŠ” ê²½ìš°ì´ë‹¤.

### ğŸªš ë‹¨ì 
- ë°ì´í„°ì˜ ìµœëŒ“ê°’ì— í•´ë‹¹í•˜ëŠ” ë§Œí¼ì˜ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì´ í•„ìš”í•˜ê¸°ì—(ëˆ„ì í•© ë°°ì—´ì— ì ‘ê·¼í•˜ëŠ” ì‹œê°„ì„ $O(1)$ë¡œ í•˜ê¸° ìœ„í•´) ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì—„ì²­ë‚œ **ë©”ëª¨ë¦¬ ë‚­ë¹„**ë¥¼ ì•¼ê¸°í•  ìˆ˜ ìˆë‹¤.
  - ë§Œì•½ ì£¼ì–´ì§„ ë°ì´í„°ì˜ ê°’ ë²”ìœ„ê°€ ë„ˆë¬´ í° ê²½ìš°, ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì˜ ë‚­ë¹„ë„ ë°œìƒí•˜ê²Œ ëœë‹¤.

|Time Complexity|Space Complexity|
|:---:|:---:|
|$O(N)$|$O(N)$|

---

## ğŸ“• ì°¸ê³ 
- [Tech Interview for developer](https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html)
- [JaeYeopHan/Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm)
- [[ì•Œê³ ë¦¬ì¦˜ ê°œë…] Stable Sort &Inplace](https://velog.io/@cookncoding/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EB%85%90-Stable-Sort-Inplace)
- [ì–‘ë°©í–¥ ë²„ë¸” ì •ë ¬](https://hevton.tistory.com/192)
- [[Dual-Pivot Quick Sort] ë‘ ê°œì˜ í”¼ë´‡ìœ¼ë¡œ í€µ ì •ë ¬](https://cs-vegemeal.tistory.com/53)
- [Counting Sort : ê³„ìˆ˜ ì •ë ¬](https://bowbowbow.tistory.com/8)
- [ê¸°ìˆ˜ ì •ë ¬-Radix Sort](https://herong.tistory.com/entry/%EA%B8%B0%EC%88%98%EC%A0%95%EB%A0%ACRidix-Sort?category=818669)